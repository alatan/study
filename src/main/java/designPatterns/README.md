### 设计模式
##### 书籍名称：设计模式之蝉
##### 书籍在线链接：https://www.kancloud.cn/sstd521/design/193489

---------------------------------------
### 创建类模式（提供对象的创建和管理职责）
***创建类模式包括工厂方法模式、建造者模式、抽象工厂模式、单例模式和原型模式。***<br>
其中的单例模式和原型模式非常容易理解，单例模式是要保持在内存中只有一个对象，原型模式是要求通过复制的方式产生一个新的对象，这两个不容易混淆。<br>
剩下的就是工厂方法模式、抽象工厂模式和建造者模式了，这三个之间有较多的相似性。<br>

| 类别 | 工厂方法模式 | 建造者模式 | 
---- | ---|  ---| 
意图不同 | 整体对象的创建方法 |  部件构建的过程，各个部件的产生以及装配顺序
产品的复杂度不同 | 单一性质产品 |  复合产品，它由各个部件复合而成，部件不同产品对象当然不同

---------------------------------------
### 结构类模式（通过组合类或对象产生更大结构以适应更高层次的逻辑需求）
***结构类模式包括适配器模式、桥梁模式、组合模式、装饰模式、门面模式、享元模式和代理模式。***<br>

##### 代理模式VS装饰模式
1. 相同点装饰模式就是代理模式的一个特殊应用，两者的共同点是都具有相同的接口
2. 不同点则是代理模式着重对代理过程的控制，而装饰模式则是对类的功能进行加强或减弱，它着重类的功能变化，我们举例来说明它们的区别。
3. 代理模式是把当前的行为或功能委托给其他对象执行，代理类负责接口限定：是否可以调用真实角色，以及是否对发送到真实角色的消息进行变形处理，<br>
    它不对被主题角色（也就是被代理类）的功能做任何处理，保证原汁原味的调用。代理模式使用到极致开发就是AOP，这是各位采用Spring架构开发必然要使用到的技术，<br>
    它就是使用了代理和反射的技术。
4. 装饰模式是在要保证接口不变的情况下加强类的功能，它保证的是被修饰的对象功能比原始对象丰富（当然，也可以减弱），但不做准入条件判断和准入参数过滤，<br>
    如是否可以执行类的功能，过滤输入参数是否合规等，这不是装饰模式关心的。<br>

---------------------------------------
##### 装饰模式VS适配器模式
1. 相同点都是包装作用，都是通过委托方式实现其功能。
2. 不同点是：装饰模式包装的是自己的兄弟类，隶属于同一个家族（相同接口或父类）<br>
    适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。
    
##### 包装模式群PK
1. 代理模式主要用在不希望展示一个对象内部细节的场景中，比如一个远程服务不需要把远程连接的所有细节都暴露给外部模块，通过增加一个代理类，
   可以很轻松地实现被代理类的功能封装。此外，代理模式还可以用在一个对象的访问需要限制的场景中，比如AOP。
2. 装饰模式是一种特殊的代理模式，它倡导的是在不改变接口的前提下为对象增强功能，或者动态添加额外职责。就扩展性而言，它比子类更加灵活，
   例如在一个已经运行的项目中，可以很轻松地通过增加装饰类来扩展系统的功能。
3. 适配器模式的主要意图是接口转换，把一个对象的接口转换成系统希望的另外一个接口，这里的系统指的不仅仅是一个应用，也可能是某个环境，
   比如通过接口转换可以屏蔽外界接口，以免外界接口深入系统内部，从而提高系统的稳定性和可靠性。
4. 桥梁模式是在抽象层产生耦合，解决的是自行扩展的问题，它可以使两个有耦合关系的对象互不影响地扩展，比如对于使用笔画图这样的需求，
   可以采用桥梁模式设计成用什么笔（铅笔、毛笔）画什么图（圆形、方形）的方案，至于以后需求的变更，如增加笔的类型，增加图形等，对该设计来说是小菜一碟。
5. 门面模式是一个粗粒度的封装，它提供一个方便访问子系统的接口，不具有任何的业务逻辑，仅仅是一个访问复杂系统的快速通道，没有它，子系统照样运行，
   有了它，只是更方便访问而已。

---------------------------------------
### 行为类模式（关注如何管理对象的行为）
***行为类模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。***<br>